## 树
逻辑：
除根节点之外每个节点只有一个父节点，根节点没有父节点；除叶节点之外所有节点都有一个或多个子节点，叶节点没有子节点。父节点和子节点之间用指针链接。

### 二叉树
二叉树中每个节点最多只能有两个子节点。二叉树中最重要的操作莫过于遍历，即按照某一顺序访问树中的所有节点。

- 前序遍历：先访问根节点，再访问左子节点，最后访问右子节点
- 中序遍历：先访问左子节点，再访问根节点，最后访问右子节点
- 后续遍历： 先访问左子节点，再访问右子节点，最后访问根节点

### 宽度优先遍历
先访问树的第一层节点，再访问树的第二层节点...一直到访问到最下面的一层节点。在同一层节点中，以从左到右的顺序一次访问。

### 二叉搜索树
左子节点总是小于或等于根节点，右子节点总是大于或等于根节点

### 下面是二叉树的两个特例
- 堆
最大堆 和 最小堆
最大堆：根节点的值最大
最小堆：根节点的值最小
一些快速找到最大值或者最小值的问题都可以用堆来解决
- 红黑树
把树中的节点定义为红、黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍

## 栈
后进先出， 最后压入push栈的元素，第一个弹出pop
## 队列
先进先出

## 递归
在一个函数的内部调用这个函数自身

## 循环
通过设置计算的初始值及终止条件，在一个范围内重复运算

## 哈希表
最主要的优点：利用它能够在O(1)时间内查找某一元素，效率最高
缺点：需要额外的空间来实现哈希表

 
## 常见的规律
- 基于递归的实现方法代码比较简洁，但性能不如基于循环的实现方法
- 二维数组(迷宫或者棋盘)上搜索路径，尝试用 回溯法（使用用递归实现，不然才用栈实现）
- 求某个问题的最优解，并且该问题可以分为多个子问题 - 动态规划
- 分解问题的时候是不是存在某个特殊的选择，如果采用这个特殊的选择将一定能得到最优解 - 贪婪算法

## 面试小提示
- 通常基于递归实现的代码比基于循环实现的代码要简洁很多，更容易实现。如果面试官没有特殊要求，我们优先采用递归的方法
- 要求在排序的数组(或者部分排序的数组)种查找一个数字或者统计某个数字出现的次数 - 尝试用二分查找算法


## 递归的负面问题？
递归由于是函数调用自身，而函数调用是有时间和空间消耗的：每次函数调用，都需要在内存栈中分配空间
以保存参数、返回地址及临时变量，而且往栈里压入数据和弹出数据都需要时间， 由于每个进展的栈容量都是
有限的。当递归调用的层级太多时，就会超出栈的容量，从而导致调用**栈溢出**。

调用栈溢出

## 动态规划
特点
1. 求一个问题的最优解
2. 最优解是依赖各个子问题的最优解
3. 大问题分解成诺干个小问题，这些小问题之间还有相互重叠的更小子问题
4. 从上往下分析问题，从下往上求解问题